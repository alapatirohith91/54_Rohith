# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_9v-0Lg_TSQ2ltsyH7fauWaUWRgBwjoe
"""

!pip install lightgbm imbalanced-learn scikit-learn pandas numpy matplotlib seaborn

import pandas as pd
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import roc_auc_score, confusion_matrix, classification_report

from imblearn.over_sampling import SMOTE
from lightgbm import LGBMClassifier

import matplotlib.pyplot as plt
import seaborn as sns

from google.colab import files

uploaded = files.upload()

# Load dataset (replace with your dataset)
df = pd.read_csv('/content/PS_20174392719_1491204439457_log 2.csv')

print(df.shape)
print(df['isFraud'].value_counts(normalize=True))

# Encode transaction type
le = LabelEncoder()
df['type_encoded'] = le.fit_transform(df['type'])

# Balance change features
df['orig_balance_change'] = df['oldbalanceOrg'] - df['newbalanceOrig']
df['dest_balance_change'] = df['newbalanceDest'] - df['oldbalanceDest']

# Amount to balance ratio
df['amount_to_balance_ratio'] = df['amount'] / (df['oldbalanceOrg'] + 1)

# Zero balance anomaly flags
df['orig_zero_balance'] = (df['oldbalanceOrg'] == 0).astype(int)
df['dest_zero_balance'] = (df['oldbalanceDest'] == 0).astype(int)

# Log transform amount
df['log_amount'] = np.log1p(df['amount'])

features = [
    'type_encoded',
    'log_amount',
    'oldbalanceOrg',
    'newbalanceOrig',
    'oldbalanceDest',
    'newbalanceDest',
    'orig_balance_change',
    'dest_balance_change',
    'amount_to_balance_ratio',
    'orig_zero_balance',
    'dest_zero_balance'
]

X = df[features]
y = df['isFraud']

X_train, X_test, y_train, y_test = train_test_split(
    X, y,
    test_size=0.2,
    stratify=y,
    random_state=42
)

df['isFraud'].isna().sum()

# Remove NaNs from target
df = df.dropna(subset=['isFraud']).reset_index(drop=True)

# Recreate features and target
X = df[features].fillna(0)
y = df['isFraud']

# Stratified split
X_train, X_test, y_train, y_test = train_test_split(
    X, y,
    test_size=0.2,
    stratify=y,
    random_state=42
)

from lightgbm import LGBMClassifier

lgbm = LGBMClassifier(
    n_estimators=300,
    learning_rate=0.05,
    max_depth=6,
    class_weight='balanced',
    random_state=42,
    n_jobs=-1
)

lgbm.fit(X_train, y_train)

y_probs = lgbm.predict_proba(X_test)[:, 1]

def precision_recall_at_k(y_true, y_scores, k=1000):
    top_k_idx = np.argsort(y_scores)[::-1][:k]
    y_true_k = y_true.iloc[top_k_idx]

    precision_k = y_true_k.sum() / k
    recall_k = y_true_k.sum() / y_true.sum()

    return precision_k, recall_k

p_k, r_k = precision_recall_at_k(y_test.reset_index(drop=True), y_probs, k=1000)
print(f"Precision@1000: {p_k:.4f}")
print(f"Recall@1000: {r_k:.4f}")

threshold = 0.2
y_pred = (y_probs >= threshold).astype(int)

print(classification_report(y_test, y_pred))

roc_auc = roc_auc_score(y_test, y_probs)
print("ROC-AUC:", roc_auc)

cm = confusion_matrix(y_test, y_pred)
sns.heatmap(cm, annot=True, fmt="d", cmap="Blues")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

output = X_test.copy()
output['fraud_score'] = y_probs
output['fraud_prediction'] = y_pred

output.to_csv("fraud_score.csv", index=False)
print("fraud_score.csv exported successfully")